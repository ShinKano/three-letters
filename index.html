<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.101.1/examples/js/controls/OrbitControls.js"></script>
  <script type="module">
    // ページの読み込みを待つ
    window.addEventListener('load', init);
    var particles, count = 0;
    function init() {

      // サイズを指定
      let width = window.innerWidth;
      let height = window.innerHeight;

      // マウス座標
      let mouse = THREE.Vector2(0, 0);

      // レンダラーを作成
      const renderer = new THREE.WebGLRenderer({
        canvas: document.querySelector('#myCanvas')
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, height);

      // シーンを作成
      const scene = new THREE.Scene();
      scene.background = new THREE.Color( 0x444444 );
      // scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );


      // カメラを作成 (視野角, 画面のアスペクト比, カメラに映る最短距離, カメラに映る最遠距離)
      const camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
      camera.position.set(0, 0, 30);

      const controls = new THREE.OrbitControls(camera);
      controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 1;
			controls.maxDistance = 800;
      controls.maxPolarAngle = Math.PI / 1.4;
      controls.enableZoom = true;
      controls.autoRotate = false;

      const whiteBoardGeo = new THREE.PlaneGeometry( 40, 20, 32 );
      const whiteBoardMat = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
      const whiteBoard = new THREE.Mesh( whiteBoardGeo, whiteBoardMat );
      whiteBoard.rotation.set(0, -0.4, 0);
      scene.add( whiteBoard );

      //テキスト
      const loader = new THREE.FontLoader();
      loader.load( 'helvetiker_bold.typeface.json', function ( font ) {
        const textGeometry = new THREE.TextGeometry( 'impl', {
          font: font,
          size: 2,
          height: 2,
          curveSegments: 12
        } );
        const materials = [
          new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, overdraw: 0.5 } ),
          new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: 0.5 } )
        ];
        const textMesh = new THREE.Mesh(textGeometry, materials);
        textMesh.rotation.set(0, -0.4, 0);
        scene.add(textMesh);
      } );
      

      // 画面サイズの変更に対応
      window.addEventListener( 'resize', onWindowResize, false );

      tick();
      // 毎フレーム時に実行されるループイベントです
      function tick() {

				renderer.render( scene, camera );
        requestAnimationFrame(tick);
      }

      function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}
    }
  </script>
  <style>
    body { margin: 0;}
  </style>
</head>
<body>
  <canvas id="myCanvas"></canvas>
</body>
</html>